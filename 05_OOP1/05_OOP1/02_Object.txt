객체란?

typedef struct Animal {
  char name[30];  // 이름
  int age;        // 나이

  int health;  // 체력
  int food;    // 배부른 정도
  int clean;   // 깨끗한 정도
} Animal;

위와 같이 Animal이란 이름의 구조체를 정의한 후, 
animal 변수를 만들어서 이를 필요로 하는 함수들에게
play(list[play_with]); 와 같이 인자로 전달해주었다.
그런데 곰곰히 생각해보면 Play 함수에 인자로 전달하는 것이 매우 불필요해 보인다.
이 상황을 그림으로 생각하면 마치 러시아식 유머처럼 "Play가 Animal을 합니다!"라고 볼 수 있다.
그런데 사실은 "Animal이 Play를 한다"가 더 적절하기 때문이다.

즉 Animal 자체가 Play를 하는 것이지 Play가 Animal을 하는 것이 아니다.
만일 Animal 자체가 play를 한다는 개념을 생각하게 된다면 아래와 같은 방식으로 작성해야한다.

Animal animal;
// 여러가지 초기화 (생략)\
animal.play();   // 즉 내가 (animal 이) Play 를 한다!
animal.sleep();  // 내가 sleep 을 한다!

이렇게 하면 play 함수에 인자로 animal을 전달해 주지 않아도 된다.
왜냐하면 내가 play하는 것이기 때문에 내 정보는 이미 play 함수가 다 알고 있기 때문이다.
play 함수는 나의 상태들, 예를 들어서 체력, 배고픔 정도 등을 모두 아기 때문에
나에 대핸 적절한 처리를 할 수 있게 되는 것이다.

즉 animal은 
자신의 상태를 알려주는 변수(variable)과
자신이 한는 행동들(play, sleep 등)을 수행하는 함수(method)로 
이루어져 있다고 볼 수 있다.

결과적으로 객체는 "변수들과 참고 자료들로 이루어진 소프트웨어 덩어리"이다.
이 때 객체가 현실 세게에서의 존재하는 것들을 나타내기 위해선 추상화(abstraction)라는 과정이 필요하다.
컴퓨터 상에서 현실 세계를 100%나타낼 수 없기 때문에 적절하게 컴퓨터에서 처리할 수 있도록 바꾸는 것이다.
예를 들어 핸드폰의 경우 '전화를 한다', '문자를 보낸다'와 같은 것들은 '핸ㄷ그폰이 하는 것'이므로 함수로 추상화 시킬 수 있고,
핸드폰의 상태를 나타내는 것들(전화 번호, 배터리 잔량 등)은 변수로 춧아화 시킬 수 있다.

어떠한 객체는 정보를 나타내는 변수들과 이를 가지고 어떠한 작업을 하는 함수들로 둘러싸고 있다.
참고로 이러한 객체의 변수나 함수들을 보통 인스턴스 변수(instance variable)과 인스턴스 메소드(instance method)라고 부르게 된다.
누군가 인스턴스 메소드라고 하면 "아 그냥 객체에 정의되어 있는 함수구나"라고 생각하면 된다.

Object를 그림으로 그릴 땐 하나의 원을 생각하면 가운데 변수들이 있고 바깥쪽에 메소드가 있는 형태이다.
이렇게 메소드가 변수들을 감싸고 있는 것처럼 그리는 이유는 진짜로 변수들이 외부로부터 '보호'되고 있기 때문이다.
즉 외부에서 어떠한 객체의 인스턴스 변수의 값을 바꾸지 못하고 오직 객체의 인스턴스 함수를 통해서만 가능하다.
(물론 항상 이렇게 극단적으로 불가능한 것은 아니고 사실 사용자가 조절할 수 있다.)

이를 단순히 코드로 표현한다면, 아래와 같다.
Animal animal;
// 초기화 과정 생략
animal.food += 100;         // --> 불가능
animal.increase_food(100);  // --> 가능

우선 animal.food +=100; 자체는 외부에서 animal이라는 '객체'의 '인스턴스 변수'에 '직접'접근하는 것이기 때문에 불가능한 것이고,
animal-increase_food(100);의 경우 animal 객체의 '인스턴스 함수'를 통해서 값을 수정하는 것이라 가능하다.
이와 같이 외부에서 직접 인스턴스 변수의 값을 바꿀 수 없고 
항상 인스턴스 메소드를 통해서 간접적으로 조절하는 것을 캡슐화(Encapsulation)라고 부른다.

이 개념을 처음 들었을 때 이게 왜 필요하나 싶은 경우도 많다.
두 개가 거기서 거기인 것처럼 느겨진다.

캡슐화의 장점은 나중에 설명되겠지만 간단히 말하자면 "객체가 내부적으로 어떻게 작동하는 지 몰라도 사용할 줄 알게 된다."라고 볼 수 있다.
예를들어 animal.increase_food(100);을 하면 내부적으로 food 변수 값이 100 증가하는 것뿐만 아니라 몸무게도 바뀔 수 있고, 행복도도 올라갈 수 있고 여러가지 작업들이 일어나게 된다.

만일 increase_food 함수를 사용하지 않는다면 각 변수별로 증가한느 처리를 해주어야 했을 것이다.
하지만 이겅슨 프로그래머가 food를 100 늘리는 과정에서 정확히 어떤 일들이 일어나는 지 알아야만 가능하다는 것이다.
이는 상당히 피곤한 작업이다. 더군다나, 대형 프로젝트에선 객체들을 한 사람이 설계하는 것이 아니라 다른 사람이 작성한 것을 읽고 완벽히 이해해야 한다.

하지만 인스턴스 메소드를 이용하면 "food"를 늘리려면 increase_food를 이용하면 나머지는 알아서 처리된다.
그래서 increase_food를 이용함ㄴ 된다는 것만 알면 객체가 내부적으로 알아서 처리도기 때문에 이를 사용하는 프로그래머가 굳이 이해하지 않아도 된다.

"내부적으로 어떻게 처리가 되는 지 알 필요가 없다!"가 조금 못마땅한 경우도 있다.
잘 생각해보면 우리가 접하는 모드 전자기기들은 캡슐화되어 있다. 
노트북의 경우도 화면에 글자 'a'를 띄우기 위해서 컴퓨터 내부에서 어떤 연산이 처리되는 지 알 필요가 없다.
단순히 우리가 하는 일은 '키보드의 a를 누른다'라는, 마치 my_computer.keyboard_hit('a');라는 메소드를 호출한 것과 동일한 작업이다.
만일 노트북이 캡슐화되어 있지 않다면 아무나 컴퓨터를 사용할 수는 없을 것이다.

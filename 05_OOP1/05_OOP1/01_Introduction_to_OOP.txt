초기의 컴퓨터는 ENIAC(에니악)과 같이 거대한 크기를 자랑했다.
이러한 컴퓨터를 수 많은 진공관들 사이의 전선 연결을 바꾸어가며 전기신호를 전달하며 프로그래밍 했다.

즉 우리가 컴퓨터 상에서 소스 코드를 치는 것을 ㅈ기접 손으로 조작했다.
이는 정말로 끔찍한 일이 아닐 수 없다. 이것을 '컴퓨터 언어'라고 보기엔 좀 무리가 있다.
아무튼 진공관 상에서 단순한 배선 연결 배치로 명령을 했던 언어가 1세대 컴퓨터 언어이다.

그리거 이와 같이 전선 배치로 '컴퓨터 프로그래밍'을 수행했을 때
어딘 가에서 오류났을 때 어던 진공관이 고장났다는 의미인데 (or 전선 배치를 잘못했거나)
이를 수정하기 위해선 19000 여개의 달하는 진공관들을 확인해야 했다.

1950년대 이후 컴퓨터 내장 메모리가 만들어지고
실질적으로 '컴퓨터 프로그래밍'을 할 수 있게 되자 2세대 컴퓨터 언어가 등장했다.

가장 첫 번째로 나온 것이 어셈블리어(Assembly language)이다.
언어라기 하기 보단 컴퓨터에 직접 명령을 내리는 기계어(0과 1로 이루어짐)에 사람들이 보기 쉽게 문자열을 대응 시킨 것에 가까운 형태였다.
어셈블리어는 말그대로 기계어와 1:1 대응되어 있기 때문에 할 수 있는 동작이 매우 단순하다.
우리가 C언어에서 1+1을 계산해봐라고 쉽게 말하는 것을 
어셈블리어에서는 "1을 어디에 저장하고 또 1을 어디에 저장하고, 이제 CPU에 메모리 어디에서 1을 불러오고 또 CPU에 메모리 어디에서 1을 불러오고 이들 덧셈을 수행해" 라고 말하는 것과 동일하다.

이는 참으로 노가다이다. 이러한 컴퓨터 언어는 '저급언어(low level)'이라 부른다.
수준이 낮다는 것이 아니라 좀 더 기계어에 근접해 있다는 것을 의미한다.
그리고 이때부터 초보적인 수준의 고급언어(high level)가 등증하게 되었는데
은행과 금융쪽에서 많이 쓰였던 COBOL이나 수치 계산용으로 쓰이는 FORTRAN이 등장하게 된다.
그리고 꽤나 쉬운 언어 였떤 BASIC도 한 몫 하게 된다.

이러한 2세대 초기 언어들은 어셈블리어에 비해선 획기적인 발전이 있을 수 있다.
하지만 문제는 데이터 타입이나 프로그램 문법 구조가 완전하지 않아서 복잡한 데이터 타입을 단순히 모두 배열로 처리한다던지,
논리 구조를 모두 goto 문으로 처리한다던지의 문제가 있었다.

이렇게 하면 오류를 발생해도 찾기가 힘든, 소위 말하는 스파게티 코드가 만들어진다.
스파게티 코드란, 스파게티처럼 프로그램의 논리 구조가 뒤엉킨 상태를 의미한다.
그래서 유명한 컴퓨터 과학작 다익스트라(Dijkstra)가 Go to statement considered harmful 이라는 유명한 글을 남기게 된다.
아무튼 이 때문에 좀 더 체게적인 프로그래밍 언어가 크게 필요해졌다.

그래서 나타난 것이 3세대 프로그래밍 언어, 
절차 지향 언어(Procedural programming languagae)라고 불리는 Pascal과 그 뒤를 이어 C가 등장하게 된다.

파스칼은 지금 우리가 아니는  C언어와 유사하다. 함수라는 개념이 완성되었고(이전에도 있었으나 불완전한 면이 있었다.)
변수의 타입이 정립 되어서 기존의 배열을 남발하던 것에서 벗어날 수 있게 된다.

절차를 지향한다는 말을 살펴보다
Procedure를 지향하는 언어, 즉 프로시져(함수)를 지향한다는 것이다.
즉 프로그램을 설계할 때 중요한 부분을 하나의 프로시져로 만들어서 쪼개 처리한다는 것이다.
물론 기존의 언어들에서도 프로시져라는 것이 존재했지만 함수의 인자와 같은 개념이 없었고, 비로소 이 때야 완전한 함수라는 것이 만들어지게 되었다.

그렇게 해서 절차 지향 언어로 몇 십년을 버텨왔다.
그러나 프로그램의 크기가 예전보다 상상도 할 수 없을 만큼 거대해 지자 새로운 패러다임이 필요하게 되었다.
그것이 바로 객체 지향 언어(Object Oriented Language)이다.
이를 사용하는 언어는  C++, Java, Python, C# 등 아마 90년대 이후에 생긴 언어들은 대부분 객체 지향 언어이다.
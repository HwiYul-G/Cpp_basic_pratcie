/*
	[레퍼런스의 배열과 배열의 레퍼런스]
	레퍼런스의 배열이 과연 가능할까?
	레퍼런스는 반드시 정의와 함께 초기화를 해주어야 한다.
	따라서 아래와 같은 코드가 떠올랐을 것이다.
	
	int a, b;
	int& arr[2] = {a, b}; // error C2234: 'arr' : arrays of references are illegal

	레퍼런스의 배열을 불법(illegal)이라고 한다. 
	C++ 규정을 ㅌ찾아보면, 표준안 8.3.2/4를 보면
	There shall be no references to references, no arrays of references, and no pointers to references.
	레퍼런스의 레퍼런스, 레퍼런스의 배열, 레퍼런스의 포인터는 존재할 수 없다.

	정말로 언어 차원에서 불가능하다고 못 박아놓았다.

	그렇다면 도대체 왜 안될까?
	int& arr[2] = {a, b]; 로 해서 arr[0]는 a를 의미하고 arr[1]은 b를 의미하게 하면 안될까?
	이와 같은 주장을 하기 전에 C++ 상에서 배열이 어떤 식으로 처리되는 지 생각해보자.
	
	문법 상의 배열의 이름 arr은 arr의 첫 번째 원소의 주소값으로 변환될 수 있어야 한다.
	즉 배열의 이름이 &arr[0]가 될 수 있어야한다.
	이로 인해 arr[1]과 같은 문장이 *(arr + 1)로 바뀌어서 처리될 수 있기 때문이다.

	그런데 주소값이 존재한다는 말은 해당 원소가 메모리 상에서 존재한다는 의미와 동치이다.
	하지만 레퍼런스는 특별한 경우가 아닌ㄴ 이상 메모리 상에서 공간을 차지하지 않는다.
	따라서 이러한 모순때문에 레퍼런스들의 배열을 정의한느 것은 언어 차원에서 금기되어 있다.

	그렇다고 해서 그 반대인 '배열들의 레퍼런스'가 불가능 한 것은 아니다. 아래서 보자.
*/
#include <iostream>
int main() {
	int arr[3] = { 1,2,3 };
	int(&ref)[3] = arr; // int(*ref)[3] = &arr[0];
	/*
		ref가 arr을 참조하게 한다.
		따라서 ref[0]부터 ref[2]가 각각 arr[0]에서 arr[2]의 레퍼런스가 된다.
		포인터와 달리 배열의 레퍼런스의 경우 참조하기 위해선 반드시 배열의 크기를 명시해야 한다.
		
		따라서 int (&ref)[n] 이라면 반드시 크기가 n인 int형 배열의 별명이 되어야 한다.

		int arr[3][2] = {1,2,3,4,5,6};
		int (&ref)[3][2] = arr;
	*/

	ref[0] = 2;
	ref[1] = 3;
	ref[2] = 1;

	std::cout << arr[0] << arr[1] << arr[2] << std::endl;

	return 0;
}
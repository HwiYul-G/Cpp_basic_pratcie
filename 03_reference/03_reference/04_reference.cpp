// 참조자 이해하기

#include <iostream>

int main() {
	int x;
	int& y = x; // y는 x의 새로운 별명이다.
	int& z = y; // z는 y의 새로운 별명이다. -> int& z = x; 가 된다.
	/*
		어떤 타입 T의 참조자 타입이 T&이다.
		그런데 여기서 y가 int&니까 y의 참조자 타입(z의 타입)은 int&&이 되어야 하지 않을까?
		라고 생각할 수도 있다.

		하지만 참조자의 참조자라는 말의 의미를 생각해보면 말이 안된다는 것을 알 수 있다.
		굳이 별명의 별명을 만들 필요는 없기 때문이다.
		실제로 C++ 문법 상 참조자의 참조자를 만드는 것은 금지되어 있다.
	*/

	x = 1;
	std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

	y = 2;
	std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

	z = 3;
	std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
}
/*
	참조자를 사용하면 포인터를 사용하는 것보다 간편하게 사용할 수 있다.
	&와 *가 필요 없기 때문

	예를들어 변수를 입력할 때
	std::cin >> user_input; 을 통해 입력받을 땐 주소값을 전달하지 않았는데
	scanf("%d", &user_input); 을 통해 입력받는 경우는 &를 통해 주소값을 전달했다.
	왜냐하면 어떤 변수의 값을 다른 함수에서 바꾸기 위해선 항상 포인터로 주소값을 전달해야 하기 때문이다.
	
	하지만 여기선 cin이라는 것에 user_input을 바로 전달 했다. 그럼에도 잘 작동한다.
	
	이 이유는 cin이 레퍼런스로 user_input을 받았기 때문이다.
	따라서 포인터로 입력받을 때처럼 &를 통해 주소값으로 전달할 필요가 없다.


*/
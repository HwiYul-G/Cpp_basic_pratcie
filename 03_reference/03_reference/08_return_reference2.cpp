#include <iostream>

int function() {
	int a = 5;
	std::cout << "function 함수 내부에서 a의 주소값 : " << &a << std::endl;;
	return a;
}

int main() {
	const int& c = function();
	/*
		function()의 리턴 값을 참조자로 받았다.
		그런데 cosnt 참조자로 받으니 문제 없이 컴파일 된다.
		그리고 아래의 출력문도 잘 된다.
	*/
	std::cout << "c : " << c << std::endl;
	/*
		원칙상 함수의 리턴값은 해당 문장이 끝나면 소멸되는 것이 정상이다.
		따라서 기존에 int&로 받았을 때에는 컴파일 자체가 안된다.
		
		하지만 예외적으로 상수 레퍼런스로 리턴값을 받게 되면 해당 리턴값의 생명이 연장된다.
		그리고 그 연장되는 기간은 레퍼런스가 사라질 때 까지 이다.
	*/
	std::cout << "const int& c의 주소값 : " << &c << std::endl;
	return 0;
}
/*
							int f()			int& f()
	int a = f();	 	  값 복사됨			값 복사됨. 다만 지역 변수의 ref를 리턴하지 않도록 주의
	int& a = f();		  컴파일 오류		값 복사됨. 다만 지역 변수의 ref를 리턴하지 않도록 주의
	const int& a = f();	  가능				값 복사됨. 다만 지역 변수의 ref를 리턴하지 않도록 주의
*/

/*
	레퍼런스가 메모리 상에 반드시 존재해야 하는 경우는 어떤 경우가 있을까요? 
	그리고 메모리 상에 존재할 필요가 없는 경우는 또 어떤 경우가 있을 까요? (난이도 : 上)

	레퍼런스가 함수 내에서 별명으로만 쓰이는 경우는 필요없을 것 같다.
	하지만 메모리에 존재해야하는 경우는 
	1) 레퍼런스를 함수의 인자로 넘기는 경우
	2) ....

	=========
	함수의 매개변수를 레퍼런스로 받을 때
	매개변수로 전달할 변수의 주소값이 새로운 메모리 공간(스택)에 저장되고 포인터처럼 그 메모리 공간을 레퍼런스가 사용함
*/